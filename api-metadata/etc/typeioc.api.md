## API Report File for "typeioc"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class ApplicationError extends Error {
    constructor(params?: {
        message?: string;
        data?: {};
    });
    // (undocumented)
    readonly data: {} | undefined;
    // @internal (undocumented)
    _data?: {};
}

// @public
export class ArgumentError extends ApplicationError {
    constructor(argumentName: string, params?: {
        message?: string;
        data?: {};
    });
    // (undocumented)
    readonly argumentName: string;
    // @internal (undocumented)
    _argumentName: string;
}

// @public
export const enum CallInfo {
    Any = 5,
    Field = 6,
    Getter = 2,
    GetterSetter = 4,
    Method = 1,
    Setter = 3
}

// @public
export const callInfo: CallInfoType;

// @public
export type CallInfoType = {
    readonly method: number;
    readonly getter: number;
    readonly setter: number;
    readonly getterSetter: number;
    readonly any: number;
    readonly field: number;
};

// @public
export class CircularDependencyError extends ApplicationError {
    constructor(serviceName: string, data?: {});
    readonly serviceName: string;
    // @internal (undocumented)
    _serviceName: string;
}

// @public
export class DecoratorError extends ApplicationError {
    constructor(params?: {
        message?: string;
        data?: {};
    });
}

// @public (undocumented)
const _default: IEntryPoint;

export default _default;

// @public
export interface ICache {
    readonly instance: {
        [name: string]: any;
    };
    resolve<R>(name: string): R;
}

// @public
export interface ICallInfo {
    args: any[];
    get?: () => any;
    invoke: (args?: any | any[]) => any | void;
    name: string;
    next?: (result?: any) => any;
    result?: any;
    set?: ({}: {}) => void;
    source: {};
    type: CallInfo;
}

// @public
export interface IContainer {
    cache: ICache;
    createChild(): IContainer;
    dispose(): void;
    disposeAsync(): Promise<void>;
    resolve<R>(service: {}, ...args: {}[]): R | never;
    resolveAsync<R>(service: {}, ...args: {}[]): Promise<R>;
    resolveNamed<R>(service: {}, name: string, ...args: {}[]): R | never;
    resolveNamedAsync<R>(service: {}, name: string, ...args: {}[]): Promise<R>;
    resolveWith<R>(service: {}): IResolveWith<R> | never;
    resolveWithDependencies<R>(service: {}, dependencies: IDynamicDependency[]): R | never;
    resolveWithDependenciesAsync<R>(service: {}, dependencies: IDynamicDependency[]): Promise<R>;
    tryResolve<R>(service: {}, ...args: {}[]): R | undefined;
    tryResolveAsync<R>(service: {}, ...args: {}[]): Promise<R | undefined>;
    tryResolveNamed<R>(service: {}, name: string, ...args: {}[]): R | undefined;
    tryResolveNamedAsync<R>(service: {}, name: string, ...args: {}[]): Promise<R | undefined>;
}

// @public
export interface IContainerBuilder {
    build(): IContainer;
    copy(builder: IContainerBuilder): void;
    register<R>(service: {}): IRegistration<R>;
}

// @public
export interface IDecorator {
    build(): IContainer;
    by(service?: {}): IDecoratorResolution;
    import(builder: IContainerBuilder): void;
    provide<R>(service: {}): IDecoratorRegistration<R>;
    provideSelf<R>(): IDecoratorRegistration<R>;
    register<R>(service: {}): IRegistration<R>;
    resolveValue(value: {} | Function): ParameterDecorator;
}

// @public
export interface IDecoratorRegistration<T> {
    dispose(action: IDisposer<T>): WithDecoratorRegisterLazy<T>;
    initializeBy(action: IInitializer<T>): WithDecoratorRegisterInitializeBy<T>;
    instancePerContainer(): WithDecoratorRegisterScope<T>;
    lazy(): WithDecoratorRegisterLazy<T>;
    named(name: string): WithDecoratorRegisterName<T>;
    ownedBy(owner: Owner): WithDecoratorRegister<T>;
    ownedExternally(): WithDecoratorRegister<T>;
    ownedInternally(): WithDecoratorRegister<T>;
    register(): ClassDecorator;
    singleton(): WithDecoratorRegisterScope<T>;
    transient(): WithDecoratorRegisterScope<T>;
    within(scope: Scope): WithDecoratorRegisterScope<T>;
}

// @public
export interface IDecoratorResolution {
    args(...value: any[]): WithDecoratorResolverArgs;
    attempt(): WithDecoratorResolverAttempt;
    cache(name?: string): WithDecoratorResolver;
    name(value: string): WithDecoratorResolverName;
    resolve(): ParameterDecorator;
}

// @public
export interface IDisposer<T> {
    // (undocumented)
    (item: T): void;
}

// @public
export interface IDynamicDependency {
    factory?: IFactory<{}>;
    factoryType?: {};
    factoryValue?: {};
    initializer?: IInitializer<{}>;
    named?: string;
    required?: boolean;
    service: {};
}

// @public
export interface IEntryPoint {
    createBuilder(): IContainerBuilder;
    createDecorator(): IDecorator;
    createInterceptor(): IInterceptor;
}

// @public
export interface IFactory<T> {
    // (undocumented)
    (c: IContainer, ...args: any[]): T;
}

// @public
export interface IInitializer<T> {
    // (undocumented)
    (c: IContainer, item: T): T;
}

// @public
export interface IInterceptor {
    intercept<R extends Function | Object>(subject: R, substitutes?: ISubstituteInfo | ISubstituteInfo[]): R;
    interceptInstance<R extends Object>(subject: R, substitutes?: ISubstituteInfo | ISubstituteInfo[]): R;
    interceptPrototype<R extends Function>(subject: R, substitutes?: ISubstituteInfo | ISubstituteInfo[]): R;
    withSubstitute(substitute: ISubstituteInfo): IWithSubstituteResult;
}

// @public
export interface IName {
    // (undocumented)
    named(name: string): void;
}

// @public
export interface IRegisterWithAs<T> {
    dispose(action: IDisposer<T>): RegisterWithLazy<T>;
    initializeBy(action: IInitializer<T>): RegisterWithInitializeBy<T>;
    instancePerContainer(): RegisterWithScope<T>;
    lazy(): RegisterWithLazy<T>;
    named(name: string): RegisterWithName<T>;
    ownedBy(owner: Owner): void;
    ownedExternally(): void;
    ownedInternally(): void;
    singleton(): RegisterWithScope<T>;
    transient(): RegisterWithScope<T>;
    within(scope: Scope): RegisterWithScope<T>;
}

// @public
export interface IRegistration<T> {
    as(factory: IFactory<T>): IRegisterWithAs<T>;
    asSelf(...params: any[]): IRegisterWithAs<T>;
    asType(type: T, ...params: any[]): IRegisterWithAs<T>;
    asValue(value: {}): IName;
}

// @public
export interface IResolveWith<T> {
    args(...args: any[]): ResolveWithArgs<T>;
    attempt(): ResolveWithAttempt<T>;
    cache(name?: string): ResolveWithCache<T>;
    dependencies(dependencies: IDynamicDependency | IDynamicDependency[]): ResolveWithName<T>;
    exec(): T;
    execAsync(): Promise<T>;
    name(value: string): ResolveWithName<T>;
}

// @public
export interface ISubstituteInfo {
    method?: string;
    type?: CallInfo;
    wrapper: (callInfo: ICallInfo) => any | void;
}

// @public
export interface IWithSubstituteResult {
    intercept: <R extends (Function | Object)>(subject: R) => R;
    interceptInstance: <R extends Object>(subject: R) => R;
    interceptPrototype: <R extends Function>(subject: R) => R;
    withSubstitute: (substitute: ISubstituteInfo) => IWithSubstituteResult;
}

// @public
export const enum Owner {
    Container = 1,
    Externals = 2
}

// @public
export const owner: OwnerType;

// @public
export type OwnerType = {
    readonly container: number;
    readonly externals: number;
};

// @public
export class ProxyError extends ApplicationError {
    constructor(params?: {
        message?: string;
        data?: {};
    });
}

// Warning: (ae-forgotten-export) The symbol "Omit" needs to be exported by the entry point index.d.ts
// 
// @public
export type RegisterWithInitializeBy<T> = Omit<IRegisterWithAs<T>, 'initializeBy'>;

// @public
export type RegisterWithLazy<T> = Omit<RegisterWithInitializeBy<T>, 'lazy' | 'dispose'>;

// @public
export type RegisterWithName<T> = Omit<RegisterWithLazy<T>, 'named'>;

// @public
export type RegisterWithScope<T> = Pick<IRegisterWithAs<T>, 'ownedBy' | 'ownedInternally' | 'ownedExternally'>;

// @public
export class ResolutionError extends ApplicationError {
    constructor(params?: {
        message?: string;
        data?: {};
        error?: Error;
    });
    readonly innerError: Error | undefined;
    // @internal (undocumented)
    _innerError?: Error;
}

// @public
export type ResolveWithArgs<T> = Omit<IResolveWith<T>, 'args'>;

// @public
export type ResolveWithAttempt<T> = Omit<ResolveWithArgs<T>, 'attempt'>;

// @public
export type ResolveWithCache<T> = Pick<IResolveWith<T>, 'exec' | 'execAsync'>;

// @public
export type ResolveWithName<T> = Omit<ResolveWithAttempt<T>, 'name'>;

// @public
export const enum Scope {
    Container = 2,
    Hierarchy = 3,
    None = 1
}

// @public
export const scope: ScopeType;

// @public
export type ScopeType = {
    readonly none: number;
    readonly container: number;
    readonly hierarchy: number;
};

// @public
export type WithDecoratorRegister<T> = Pick<IDecoratorRegistration<T>, 'register'>;

// @public
export type WithDecoratorRegisterInitializeBy<T> = Omit<IDecoratorRegistration<T>, 'initializeBy'>;

// @public
export type WithDecoratorRegisterLazy<T> = Omit<WithDecoratorRegisterInitializeBy<T>, 'lazy' | 'dispose'>;

// @public
export type WithDecoratorRegisterName<T> = Omit<WithDecoratorRegisterLazy<T>, 'named'>;

// @public
export type WithDecoratorRegisterScope<T> = Omit<WithDecoratorRegisterName<T>, 'within' | 'transient' | 'singleton' | 'instancePerContainer'>;

// @public
export type WithDecoratorResolver = Pick<IDecoratorResolution, 'resolve'>;

// @public
export type WithDecoratorResolverArgs = Omit<IDecoratorResolution, 'args'>;

// @public
export type WithDecoratorResolverAttempt = Omit<WithDecoratorResolverArgs, 'attempt'>;

// @public
export type WithDecoratorResolverName = Omit<WithDecoratorResolverAttempt, 'name'>;


```
