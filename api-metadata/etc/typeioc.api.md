## API Report File for "typeioc"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class ApplicationError extends Error {
    constructor(params?: {
        message?: string;
        data?: {};
    });
    // (undocumented)
    readonly data: {} | undefined;
    // @internal (undocumented)
    _data?: {};
}

// @public
export class ArgumentError extends ApplicationError {
    constructor(argumentName: string, params?: {
        message?: string;
        data?: {};
    });
    // (undocumented)
    readonly argumentName: string;
    // @internal (undocumented)
    _argumentName: string;
}

// @public
export const builder: () => IContainerBuilder;

// @public
export const callInfo: Readonly<{
    method: CallInfoType;
    getter: CallInfoType;
    setter: CallInfoType;
    getterSetter: CallInfoType;
    any: CallInfoType;
    field: CallInfoType;
}>;

// @public
export type CallInfoType = 1 | 2 | 3 | 4 | 5 | 6;

// @public
export class CircularDependencyError extends ApplicationError {
    constructor(serviceName: string, data?: {});
    readonly serviceName: string;
    // @internal (undocumented)
    _serviceName: string;
}

// @public
export const decorator: () => IDecorator;

// @public
export class DecoratorError extends ApplicationError {
    constructor(params?: {
        message?: string;
        data?: {};
    });
}

// @public
export interface ICache {
    readonly instance: {
        [name: string]: any;
    };
    resolve<R>(name: string): R;
}

// @public
export interface ICallInfo {
    args: any[];
    get?: () => any;
    invoke: (args?: any | any[]) => any | void;
    name: string;
    next?: (result?: any) => any;
    result?: any;
    set?: ({}: {}) => void;
    source: {};
    type: CallInfoType;
}

// @public
export interface IContainer {
    cache: ICache;
    createChild(): IContainer;
    dispose(): void;
    disposeAsync(): Promise<void>;
    resolve<R>(service: {}, ...args: {}[]): R | never;
    resolveAsync<R>(service: {}, ...args: {}[]): Promise<R>;
    resolveNamed<R>(service: {}, name: string, ...args: {}[]): R | never;
    resolveNamedAsync<R>(service: {}, name: string, ...args: {}[]): Promise<R>;
    resolveWith<R>(service: {}): IResolveWith<R> | never;
    resolveWithDependencies<R>(service: {}, dependencies: IDynamicDependency[]): R | never;
    resolveWithDependenciesAsync<R>(service: {}, dependencies: IDynamicDependency[]): Promise<R>;
    tryResolve<R>(service: {}, ...args: {}[]): R | undefined;
    tryResolveAsync<R>(service: {}, ...args: {}[]): Promise<R | undefined>;
    tryResolveNamed<R>(service: {}, name: string, ...args: {}[]): R | undefined;
    tryResolveNamedAsync<R>(service: {}, name: string, ...args: {}[]): Promise<R | undefined>;
}

// @public
export interface IContainerBuilder {
    build(): IContainer;
    copy(builder: IContainerBuilder): void;
    register<R>(service: {}): IRegistration<R>;
}

// @public
export interface IDecorator {
    build(): IContainer;
    by(service?: {}): IDecoratorResolution;
    import(builder: IContainerBuilder): void;
    provide<R>(service: {}): IDecoratorRegistration<R>;
    provideSelf<R>(): IDecoratorRegistration<R>;
    register<R>(service: {}): IRegistration<R>;
    resolveValue(value: {} | Function): ParameterDecorator;
}

// @public
export interface IDecoratorRegistration<T> {
    dispose<K extends T>(action: IDisposer<K>): WithDecoratorRegisterLazy<K>;
    initializeBy<K extends T>(action: IInitializer<K>): WithDecoratorRegisterInitializeBy<K>;
    instancePerContainer(): WithDecoratorRegister<T>;
    lazy(): WithDecoratorRegisterLazy<T>;
    named(name: string): WithDecoratorRegisterName<T>;
    register(): ClassDecorator;
    singleton(): WithDecoratorRegister<T>;
    transient(): WithDecoratorRegister<T>;
    within(scope: ScopeType): WithDecoratorRegister<T>;
}

// @public
export interface IDecoratorResolution {
    args(...value: any[]): WithDecoratorResolverArgs;
    attempt(): WithDecoratorResolverAttempt;
    cache(name?: string): WithDecoratorResolver;
    name(value: string): WithDecoratorResolverName;
    resolve(): ParameterDecorator;
}

// @public
export interface IDisposer<T> {
    // (undocumented)
    (item: T): void;
}

// @public
export interface IDynamicDependency {
    factory?: IFactory<{}>;
    factoryType?: {};
    factoryValue?: {};
    initializer?: IInitializer<{}>;
    named?: string;
    required?: boolean;
    service: {};
}

// @public
export interface IFactory<T> {
    // (undocumented)
    (c: IContainer, ...args: any[]): T;
}

// @public
export interface IInitializer<T> {
    // (undocumented)
    (c: IContainer, item: T): T;
}

// @public
export interface IInterceptor {
    intercept<R extends Function | Object>(subject: R, substitutes?: ISubstituteInfo | ISubstituteInfo[]): R;
    interceptInstance<R extends Object>(subject: R, substitutes?: ISubstituteInfo | ISubstituteInfo[]): R;
    interceptPrototype<R extends Function>(subject: R, substitutes?: ISubstituteInfo | ISubstituteInfo[]): R;
    withSubstitute(substitute: ISubstituteInfo): IWithSubstituteResult;
}

// @public
export interface IName {
    // (undocumented)
    named(name: string): void;
}

// @public
export const interceptor: () => IInterceptor;

// @public
export interface IRegisterWithAs<T> {
    dispose<K extends T>(action: IDisposer<K>): RegisterWithLazy<K>;
    initializeBy<K extends T>(action: IInitializer<K>): RegisterWithInitializeBy<K>;
    instancePerContainer(): void;
    lazy(): RegisterWithLazy<T>;
    named(name: string): RegisterWithName<T>;
    singleton(): void;
    transient(): void;
    within(scope: ScopeType): void;
}

// @public
export interface IRegistration<T> {
    as(factory: IFactory<T>): IRegisterWithAs<T>;
    asSelf(...params: any[]): IRegisterWithAs<T>;
    asType(type: T, ...params: any[]): IRegisterWithAs<T>;
    asValue(value: {}): IName;
}

// @public
export interface IResolveWith<T> {
    args(...args: any[]): ResolveWithArgs<T>;
    attempt(): ResolveWithAttempt<T>;
    cache(name?: string): ResolveWithCache<T>;
    dependencies(dependencies: IDynamicDependency | IDynamicDependency[]): ResolveWithName<T>;
    exec(): T;
    execAsync(): Promise<T>;
    name(value: string): ResolveWithName<T>;
}

// @public
export interface ISubstituteInfo {
    method?: string;
    type?: CallInfoType;
    wrapper: (callInfo: ICallInfo) => any | void;
}

// @public
export interface IWithSubstituteResult {
    intercept: <R extends (Function | Object)>(subject: R) => R;
    interceptInstance: <R extends Object>(subject: R) => R;
    interceptPrototype: <R extends Function>(subject: R) => R;
    withSubstitute: (substitute: ISubstituteInfo) => IWithSubstituteResult;
}

// @public
export class ProxyError extends ApplicationError {
    constructor(params?: {
        message?: string;
        data?: {};
    });
}

// Warning: (ae-forgotten-export) The symbol "Omit" needs to be exported by the entry point index.d.ts
// 
// @public
export type RegisterWithInitializeBy<T> = Omit<IRegisterWithAs<T>, 'initializeBy'>;

// @public
export type RegisterWithLazy<T> = Omit<RegisterWithInitializeBy<T>, 'lazy' | 'dispose'>;

// @public
export type RegisterWithName<T> = Omit<RegisterWithLazy<T>, 'named'>;

// @public
export class ResolutionError extends ApplicationError {
    constructor(params?: {
        message?: string;
        data?: {};
        error?: Error;
    });
    readonly innerError: Error | undefined;
    // @internal (undocumented)
    _innerError?: Error;
}

// @public
export type ResolveWithArgs<T> = Omit<IResolveWith<T>, 'args'>;

// @public
export type ResolveWithAttempt<T> = Omit<ResolveWithArgs<T>, 'attempt'>;

// @public
export type ResolveWithCache<T> = Pick<IResolveWith<T>, 'exec' | 'execAsync'>;

// @public
export type ResolveWithName<T> = Omit<ResolveWithAttempt<T>, 'name'>;

// @public
export const scope: Readonly<{
    none: ScopeType;
    container: ScopeType;
    hierarchy: ScopeType;
}>;

// @public
export type ScopeType = 1 | 2 | 3;

// @public
export type WithDecoratorRegister<T> = Pick<IDecoratorRegistration<T>, 'register'>;

// @public
export type WithDecoratorRegisterInitializeBy<T> = Omit<IDecoratorRegistration<T>, 'initializeBy'>;

// @public
export type WithDecoratorRegisterLazy<T> = Omit<WithDecoratorRegisterInitializeBy<T>, 'lazy' | 'dispose'>;

// @public
export type WithDecoratorRegisterName<T> = Omit<WithDecoratorRegisterLazy<T>, 'named'>;

// @public
export type WithDecoratorResolver = Pick<IDecoratorResolution, 'resolve'>;

// @public
export type WithDecoratorResolverArgs = Omit<IDecoratorResolution, 'args'>;

// @public
export type WithDecoratorResolverAttempt = Omit<WithDecoratorResolverArgs, 'attempt'>;

// @public
export type WithDecoratorResolverName = Omit<WithDecoratorResolverAttempt, 'name'>;


```
